#!/usr/bin/perl

#USAGE: Run with no options to get usage or with --help for basic details

#Robert W. Leach
#Princeton University
#Carl Icahn Laboratory
#Lewis Sigler Institute for Integrative Genomics
#Bioinformatics Group
#Room 137A
#Princeton, NJ 08544
#rleach@princeton.edu
#Copyright 2017

#Template version: 1.0

use warnings;
use strict;
use CommandLineInterface;

setScriptInfo(VERSION => '1.0',
              CREATED => '6/22/2017',
              AUTHOR  => 'Robert William Leach',
              CONTACT => 'rleach@princeton.edu',
              COMPANY => 'Princeton University',
              LICENSE => 'Copyright 2017',
              HELP    => << 'END_HELP'

This script takes a sequence variant file in VCF format and sorts the records in the file in ranked order, with optional filtering.  If you have multiple samples for a variant on each row, you can define groups of samples, each with criteria to be met to keep each row, or filter it out.  E.g. You can specify that the genotype of a variant in samples 1 & 2 must be different from the genotype of the variant in samples 3 & 4.  Or you can specify that the genotype of the variant in at least N samples (1, 2, and 3) must differ from the genotype of the variant in at least M samples (4, 5, 6, and 7).

END_HELP
	     );

setDefaults(HEADER        => 1,
	    ERRLIMIT      => 3,
	    COLLISIONMODE => 'error',
	    DEFRUNMODE    => 'usage',
	    DEFSDIR       => undef);

my $format_index            = 8;
my $sample_name_start_index = $format_index + 1;

my $vcf_type_id =
  addInfileOption(GETOPTKEY   => 'i|vcf-file|input-file=s',
		  REQUIRED    => 1,
		  PRIMARY     => 1,
		  DEFAULT     => undef,
		  SMRY_DESC   => 'VCF input file (generated by FreeBayes).',
		  FORMAT_DESC => << 'END_FORMAT'

A VCF file is a plain text, tab-delimited file.  The format is generally described here: http://bit.ly/2sulKcZ

However, the important parts that this script relies on are:

1. The column header line (in particular - looking for the FORMAT and sample name columns).
2. The colon-delimited codes in the FORMAT column values, specifically AO (the number of reads supporting the variant) and DP (Read depth)
3. The colon-delimited values in the sample columns that correspond to the positions defined in the FORMAT column.

The file may otherwise be a standard VCF file containing header lines preceded by '##'.  Empty lines are OK and will be printed regardless of parameters supplied to this script.  Note, the --header and --no-header flags of this script do not refer to the VCF file's header, but rather the script run info header.  Note that with the script run info header, the output is no longer a standard VCF format file.  Use --no-header and the format of the output will be consistent with a standard VCF file.

END_FORMAT
		 );

my $sample_groups = [];
add2DArrayOption(GETOPTKEY   => 's|sample-group|filter-group=s',
		 GETOPTVAL   => $sample_groups,
		 DEFAULT     => 'none',
		 SMRY_DESC   => 'List of sample names for filtering.',
		 DETAIL_DESC => << 'END_DETAIL'

This is a filtering option that allows you to arbitrarily define pairs of groups of samples in which to require a minimum number of members' genotype state of a variant to differ in order to pass filtering.  For example, if you have 3 wildtype samples and 4 mutant samples, you can define these 2 groups using -s 's1 s2 s3' -s 's4 s5 s6 s7' (where 's1' and other sample names match the sample names in the VCF column headers row).  If you want to require that at least 1 of the mutants differ from all the wildtype samples, after defining these groups, you would use: -d 3 -d 1.  The ordering of the options is important

END_DETAIL
		);

my $group_diff_mins = [];
addArrayOption(GETOPTKEY   => 'd|group-diff-min=s',
	       GETOPTVAL   => $group_diff_mins,
	       DEFAULT     => 'all',
	       SMRY_DESC   => 'Number of group samples required to differ.',
	       DETAIL_DESC => << 'END_DETAIL'

Sample groups defined by -s are procssed in pairs.  Each -s group is accompanied by a minimum number of samples in that group that are required to be different from the genotype of its partner group.  "Different" in this case means the genotype state of each sample for the variant defined by the VCF record (a data row/line in the VCF file).

END_DETAIL
		);

my $min_support_ratio = 0.7;
addOption(GETOPTKEY   => 'm|min-support-ratio=s',
	  GETOPTVAL   => \$min_support_ratio,
	  DEFAULT     => $min_support_ratio,
	  SMRY_DESC   => 'Minimum ratio of variant-supporting reads vs total.',
	  DETAIL_DESC => ('Minimum ratio of reads supporting a variant ' .
			  '(over total reads that mapped over the variant) ' .
			  'in order to keep the row/line/record.  If any ' .
			  'sample meets this requirement, the entire ' .
			  'record is kept (potentially including samples ' .
			  'which failed this filter).  Applies to all ' .
			  'samples.'));

my $min_read_depth = 2;
addOption(GETOPTKEY   => 'r|min-read-depth=i',
	  GETOPTVAL   => \$min_read_depth,
	  DEFAULT     => $min_read_depth,
	  SMRY_DESC   => 'Minimum number of reads mapped over a variant.',
	  DETAIL_DESC => ('Minimum number of reads required to have mapped ' .
			  'over a variant position in order to make a ' .
			  'variant call.  If any sample meets this ' .
			  'requirement, the entire record is kept ' .
			  '(potentially including samples which failed this ' .
			  'filter).  Applies to all samples.'));

processCommandLine();

#There must be an even number of sample groups
if(scalar(@$sample_groups) % 2)
  {
    error("There must be 2 (or an even number of) sample groups, but [",
	  scalar(@$sample_groups),"] were supplied.  See the usage ",
	  "description for -s for details.");
    quit(1);
  }

#Construct default values for the group_diff_mins if they weren't all supplied
if(scalar(@$sample_groups) &&
   scalar(@$sample_groups) != scalar(@$group_diff_mins))
  {
    my $all = (scalar(@$group_diff_mins) == 0);
    foreach my $sample_group_index (0..$#{$sample_groups})
      {
	if(scalar(@$group_diff_mins) < ($sample_group_index + 1))
	  {
	    if($all || ($group_diff_mins->[0] >
			scalar(@{$sample_groups->[$sample_group_index]})))
	      {$group_diff_mins->[$sample_group_index] =
		 scalar(@{$sample_groups->[$sample_group_index]})}
	    else
	      {$group_diff_mins->[$sample_group_index] = $group_diff_mins->[0]}
	  }
      }
  }

#If sample groups and multiple group diff mins were submitted
if(scalar(@$sample_groups) && scalar(@$group_diff_mins) > 1)
  {
    #There must be an equal number of group diff mins and their values must be
    #less than or equal to the group sizes
    if(scalar(@$group_diff_mins) != scalar(@$sample_groups) ||
       scalar(grep {$group_diff_mins->[$_] < 1 ||
		      $group_diff_mins->[$_] > scalar(@{$sample_groups->[$_]})}
	      (0..$#{$sample_groups})))
      {
	error("The group diff mins (-d) [",join(',',@$group_diff_mins),
	      "] must each be a positive value less than or equal to the ",
	      "number of members in the corresponding sample group [",
	      join(',',map {scalar(@$_)} @$sample_groups),"].  To require ",
	      "all members of each group be different, do not supply -d.  ",
	      "Unable to proceed.");
	quit(2);
      }
  }
elsif(scalar(@$sample_groups) && scalar(@$group_diff_mins) == 1)
  {
    #The values of the group diff mins must be less than or equal to the group
    #sizes
    if(scalar(grep {$group_diff_mins->[0] >= 0 &&
		      $group_diff_mins->[0] <=
			scalar(@{$sample_groups->[$_]})}
	      (0..$#{$sample_groups})) != 0)
      {
	warning("The group diff min (-d) should be a positive value less ",
		"than or equal to the number of members in each sample ",
		"group.  Note, the value will be reduced to the group size ",
		"for those groups that are smaller.");
      }
  }

#NOTE: One of the group_diff_mins in each pair must represent a majority of the
#corresponding group
if(scalar(@$sample_groups) &&
   scalar(grep {($group_diff_mins->[$_] >
		 (scalar(@{$sample_groups->[$_]}) / 2)) ||
		   ($group_diff_mins->[$_ + 1] >
		    (scalar(@{$sample_groups->[$_ + 1]}) / 2))}
	  grep {$_ % 2 == 0} (0..$#{$sample_groups})) == 0)
  {
    error("One of each pair of group diff mins (-d) must represent a ",
	  "majority of the number of members in its corresponding sample ",
	  "group.",
	  {DETAIL => "One group must serve as an unambiguous reference " .
	   "genotype.  It can be a single sample or a set of replicate " .
	   "samples.  This makes the results more interpretable."});
    quit(3);
  }

while(nextFileCombo())
  {
    my $inputFile = getInfile();
    my $outputFile = getOutfile();

    openIn(*IN,$inputFile);

    my $line_num  = 0;
    my @samples   = ();
    my $data_line = 0;
    my @passed    = ();

    while(getLine(*IN)) #Using this method provides verbose functionality and
      {                 #automatic conversion of carriage return characters
	$line_num++;
	verboseOverMe({FREQUENCY => 100},
		      "[$inputFile] Reading line: [$line_num].");

	#If this is a header line that is not the (first) column header line
	if(/^##/ || (scalar(@samples) && /^#/) || /^\s*$/)
	  {
	    print;
	    next;
	  }

	chomp;
	my @cols = split(/\t/,$_,-1);

	#If this is the (first) column header line
	if(/^#[^#].*\t/ && scalar(@samples) == 0)
	  {
	    #Get the index of the FORMAT column - we will assume that the
	    #sample columns start immediately after and go to the end
	    if(/\tFORMAT\t/)
	      {
		#Assuming only 1 FORMAT column header
		$format_index = (grep {$cols[$_] eq 'FORMAT'} (0..$#cols))[0];
		$sample_name_start_index = $format_index + 1;
	      }
	    else
	      {
		warning("FORMAT column header not found on column header ",
			"line.  Using default expected FORMAT column number [",
			($format_index + 1),"] and sample column start ",
			"number [",($sample_name_start_index + 1),"].");
	      }

	    #If -s was supplied, the sample names in the column header are
	    #necessary - otherwise, we can assume that the header is just
	    #malformed and that the samples are where we would otherwise expect
	    #them to be in a standard VCF file (as produced by FreeBayes).
	    if(scalar(@samples) &&
	       scalar(@cols) < ($sample_name_start_index + 1))
	      {
		error("No columns for sample names were found on the ",
		      "column header line: [$_].  Unable to finish ",
		      "processing file [$inputFile].",
		      {DETAIL => "Sample names in the column header are " .
		       "used to identify sample columns for use with the -s " .
		       "and -d parameters, and to find the number of " .
		       "supporting read and total reads for each record.  " .
		       "If your column header line is malformed, but the " .
		       "data is there and you do not supply -s or -d, you " .
		       "will still be able to proceed using the default " .
		       "FORMAT column number [",($format_index + 1),"] and " .
		       "sample column start number [",
		       ($sample_name_start_index + 1),"]."});

		last;
	      }

	    @samples = @cols[$sample_name_start_index..$#cols];
	    s/#//;

	    #Print the new header
	    print("#NUMHITS,SEARCHCRITERIA\tSNPREAD/DEPTH\tSNPSAMPLES\t$_\n");

	    next;
	  }
	elsif(scalar(@samples) == 0)
	  {
	    warning("Column header line not found before data.  Using ",
		    "default expected FORMAT column number [",
		    ($format_index + 1),"] and sample column start number [",
		    ($sample_name_start_index + 1),"].");
	  }

	if(scalar(@cols) < ($sample_name_start_index + 1))
	  {
	    error("Sample data was not found on line: [$line_num] of VCF ",
		  "file [$inputFile].  Skipping line.",
		  {DETAIL => "Sample names in the column header are " .
		   "used to identify sample columns for use with the -s " .
		   "and -d parameters, and to find the number of " .
		   "supporting read and total reads for each record.  " .
		   "If your column header line is malformed, but the " .
		   "data is there and you do not supply -s or -d, you " .
		   "will still be able to proceed using the default " .
		   "FORMAT column number [",($format_index + 1),"] and " .
		   "sample column start number [",
		   ($sample_name_start_index + 1),"]."});

	    next;
	  }

	$data_line++;

	my $format_str = $cols[$format_index];
	my(@data)      = @cols[$sample_name_start_index..$#cols];

	debug("FORMAT string for data record [$data_line]: [$format_str].");

	#Determine the subindex of each piece of sample data based on the
	#FORMAT string by creating a hash
	my $format_subindex = 0;
	my $format_key_tosubindex = {};
	foreach my $key (split(/:/,$format_str,-1))
	  {$format_key_tosubindex->{$key} = $format_subindex++}

	if(!exists($format_key_tosubindex->{DP}))
	  {
	    error("The index of the read depth key [DP] could not be found ",
		  "in the FORMAT string in data record [$data_line] on line ",
		  "[$line_num] in file [$inputFile].  Skipping line.",
		  {DETAIL => 'The read depth per sample is required by -m ' .
		   'and -r for filtering and ranking.'});
	    next;
	  }
	elsif(!exists($format_key_tosubindex->{AO}))
	  {
	    error("The index of the key for the number of read supporting ",
		  "the alternate genotype [AO] could not be found in the ",
		  "FORMAT string in data record [$data_line] on line ",
		  "[$line_num] in file [$inputFile].  Skipping line.",
		  {DETAIL => 'The alternate genotype read support per ' .
		   'sample is required by -m for filtering and ranking.'});
	    next;
	  }

	my $got    = 0;
	my $depths = {};
	my @hits   = ();
	my @rats   = ();

	foreach my $format_subindex (0..$#samples)
	  {
	    #If there is no data for this sample (i.e. no reads mapped over the
	    #position of this variant)
	    if($data[$format_subindex] eq '.')
	      {
		#Create a bogus record so that DP and AO can be set to 0
		$data[$format_subindex] =
		  "0:"x(scalar(keys(%$format_key_tosubindex)));
		chop($data[$format_subindex]);
	      }

	    #Get the sample name for this sample column
	    my $sample = $samples[$format_subindex];

	    #Get the data specific to this sample
	    my @d = split(/:/,$data[$format_subindex],-1);

	    #Sometimes there are multiple alternate variants that are comma
	    #delimited.  We will consider the one with the most support because
	    #all we're doing is seeing if anything marks this sample as a hit
	    my $ao = max(split(/,/,$d[$format_key_tosubindex->{AO}]));

	    debug("Data for sample [$sample]: [",join(':',@d),"].");

	    #Record how many samples had adequate depth of coverage
	    $depths->{$sample}++
	      if($d[$format_key_tosubindex->{DP}] >= $min_read_depth);

	    #If the depth is adequate, greater than 0, and support for the
	    #alternate allele is adequate
	    if($d[$format_key_tosubindex->{DP}] >= $min_read_depth &&
	       $d[$format_key_tosubindex->{DP}] > 0 &&
	       ($ao / $d[$format_key_tosubindex->{DP}]) >= $min_support_ratio)
	      {
		$got++;

		#Record the ratios of alt allele support over total reads
		push(@rats,"$ao/$d[$format_key_tosubindex->{DP}]");

		#Record the sample name that was a hit
		push(@hits,$samples[$format_subindex]);
	      }
	  }

	my $anything_passed = 0;
	my $pass_str = "$got,HITS>0,HITS<" . scalar(@samples) . ",SNP/DEP>=" .
	  "$min_support_ratio,DEP>=$min_read_depth";
	if(scalar(@$sample_groups))
	  {
	    my $group_pair_rule = 0;
	    foreach my $pair_index (grep {$_ % 2 == 0} (0..$#{$sample_groups}))
	      {
		$group_pair_rule++;
		my @set1     = @{$sample_groups->[$pair_index]};
		my $set1_min = $group_diff_mins->[$pair_index];
		my @set2     = @{$sample_groups->[$pair_index + 1]};
		my $set2_min = $group_diff_mins->[$pair_index + 1];

		debug("$_\nSET1: [@set1] SET1MIN: $set1_min ",
		      "SET2: [@set2] SET2MIN: $set2_min");

		#If we got something, not all samples were hits, and either:
		# - The first sample group was a hit for the alternate allele
		#   and the second sample group was not OR
		# - The first sample group was not a hit for the alternate
		#   allele and the second sample group was
		if($got > 0 && $got < scalar(@samples) &&
		   ((scalar(grep {my $u=$_;scalar(grep {$_ eq $u} @set1)}
			    @hits) >= $set1_min &&
		     scalar(grep {my $u=$_;scalar(grep {$_ eq $u} @set2)}
			    grep {exists($depths->{$_})}
			    @hits) < $set2_min &&
		     scalar(grep {exists($depths->{$_})} @set2) >=
		     $set2_min) ||
		    (scalar(grep {my $u=$_;scalar(grep {$_ eq $u} @set1)}
			    grep {exists($depths->{$_})}
			    @hits) < $set1_min &&
		     scalar(grep {exists($depths->{$_})} @set1) >=
		     $set1_min &&
		     scalar(grep {my $u=$_;scalar(grep {$_ eq $u} @set2)}
			    @hits) >= $set2_min)))
		  {
		    debug("PASSED POS1/NEG2: [",scalar(grep {my $u=$_;scalar(grep {$_ eq $u} @set1)} @hits),'/', scalar(grep {my $u=$_;scalar(grep {$_ eq $u} @set2)} grep {exists($depths->{$_})} @hits),"] NEG1/POS2: [",scalar(grep {my $u=$_;scalar(grep {$_ eq $u} @set1)} grep {exists($depths->{$_})} @hits),'/',scalar(grep {my $u=$_;scalar(grep {$_ eq $u} @set2)} @hits),"]");
		    $anything_passed++;
		    $pass_str .= ",GROUPRULEPAIR$group_pair_rule\[SET(" .
		      join(',',@set1) . ")>=$set1_min DIFFERS FROM SET(" .
		      join(',',@set2) . ")>=$set2_min]";
		  }
		else
		  {debug("FAILED")}
	      }
	  }
	elsif($got > 0 && $got < scalar(@samples))
	  {$anything_passed++}

	if($anything_passed)
	  {push(@passed,
		join('',
		     ("$pass_str\t",join(',',@rats),"\t",join(',',@hits),
		      "\t$_")))}
      }

    closeIn(*IN);

    openOut(*OUT,$outputFile);
    print(join("\n",rank(\@passed)),"\n");
    closeOut(*OUT);
  }


sub rank
  {
    my @lines = @{$_[0]};
    return(sort
	   {
	     #If we can parse the number of hits, the allelic support over
	     #total read ratio, and the sample names that passed the filtering
	     if($a=~/^(\d+)[^\t]+\t([^\t]+)\t([^\t]+)/)
	       {
		 my $ah      = $1; #number of 'a' hits
		 my $arats   = $2; #Comma delimited 'a' ratios string
		 my $asamps  = $3; #Comma delimited 'a' sample names
		 my @anums   = split(/,/,$arats);
		 my $anumsum = 0;
		 my $adensum = 0;
		 foreach my $arat (@anums)
		   {
		     my($anum,$aden) = split(/\//,$arat);
		     $anumsum += $anum;
		     $adensum += $aden;
		   }
		 my $asup = $anumsum / $adensum;
		 if($b =~ /^(\d+)[^\t]+\t([^\t]+)\t([^\t]+)/)
		   {
		     my $bh      = $1; #number of 'b' hits
		     my $brats   = $2; #Comma delimited 'b' ratios string
		     my $bsamps  = $3; #Comma delimited 'b' sample names
		     my @bnums   = split(/,/,$brats);
		     my $bnumsum = 0;
		     my $bdensum = 0;
		     foreach my $brat (@bnums)
		       {
			 my($bnum,$bden) = split(/\//,$brat);
			 $bnumsum += $bnum;
			 $bdensum += $bden;
		       }
		     my $bsup = $bnumsum / $bdensum;

		     #This is the end result - logic for sorting
		     $bh <=> $ah || $bsup <=> $asup || $bdensum <=> $adensum ||
		       $asamps cmp $bsamps
		   }
		 else
		   {-1}
	       }
	     else
	       {-1}
	   } grep {/^\d/} @lines);
  }

sub max
  {
    my @vals = @_;
    return(undef) unless(scalar(@vals));
    my $max  = $vals[0];
    foreach my $val (@vals)
      {if(!defined($max) || $val > $max)
	 {$max = $val}}
    return($max);
  }
