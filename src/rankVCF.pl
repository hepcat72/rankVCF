#!/usr/bin/perl

#USAGE: Run with no options to get usage or with --help for basic details

#Robert W. Leach
#Princeton University
#Carl Icahn Laboratory
#Lewis Sigler Institute for Integrative Genomics
#Bioinformatics Group
#Room 137A
#Princeton, NJ 08544
#rleach@princeton.edu
#Copyright 2018

use warnings;
use strict;
use CommandLineInterface;

our $VERSION = '2.000';
setScriptInfo(VERSION => $VERSION,
              CREATED => '6/22/2017',
              AUTHOR  => 'Robert William Leach',
              CONTACT => 'rleach@princeton.edu',
              COMPANY => 'Princeton University',
              LICENSE => 'Copyright 2018',
              HELP    => << 'END_HELP'

This script sorts and (optionally) filters the rows/variants of a VCF file (containing data for 2 or more samples) based on the differences in the variant data between samples or sample groups.  "Difference" is determined by either the genotype call or allelic frequency (with a gap size threshold).  The the pair of samples or sample groups used to represent the difference for a variant row is the one leading to the greatest difference in consistent genotype or average allelic frequencies (i.e. observation ratios, e.g. AO/DP) of the same variant state.

See --help --extended for more details.

END_HELP
	      ,
	      DETAILED_HELP => << 'END_AHELP'

This script works with VCF files generated by freeBayes (for SNP and small nucleotide variants) or svTyper (for structural variants).  It will work with any other VCF data that includes GT or AO, RO, and DP tags in the FORMAT string.

Each row in a VCF file will be assumed to represent a variant (or variant position).  In the context of this script, there are two ways to look at differences among the samples: genotype calls and the ratio of observations of a particular variant out of the total observatons.  We'll refer to this as either "allelic frequency" or "observation ratios" throughout the documentation.

DEFAULT SORTING BEHAVIOR

VCF rows/variants are sorted by the (maximum) degree of difference that exists between the pairs of sample groups you define.  If multiple pairs are defined, the maximum difference computed among those pairs is used in the sort.  How the degree of difference is calculated depends on whether the --genotype or --nogenotype flag is supplied.

If --genotype is supplied, sorting will be based on the degree of difference in genotype calls between the 2 sample groups.  Put simply, variants where all the genotype calls differ between sample group 1 and sample group 2 will be at the top of the results.  If the genotype calls within a group are not consistent, the rank of the row falls and it will appear lower in the results.  If all of the genotype calls between 2 sample groups are the same, the row will be at the bottom of the results.  If samples do not have genotype calls, the rank falls even lower.  The very bottom of the results will contain variant which have no genotype calls among any samples in the 2 groups.

If --nogenotype is supplied, sorting will be based on the degree of difference in allelic frequencies between the 2 samples groups.  The degree of difference between allelic frequencies will be the maximum difference in observation ratios among the samples, e.g. an 'A' in sample 1 is seen in 1 out of 10 reads that map over the variant position whereas an 'A' is seen in sample 2 in 10 out of 10 reads.  The difference in those observation ratios is 9/10 or 0.9.  The variant state (among all the observations in the 2 sample groups) with the largest difference in observation ratios between the samples in the 2 sample groups is selected to represent the row.  The difference in average ratios of each group is what is used in the sort.

SETTING A MINIMUM GROUP SIZE

Supplying a --min-group-size affects sorting and allows you to find which samples among 2 sample groups differ (by bringing them to the top of the sorted results).  By default, all group members are used to compute maximum difference between 2 sample groups as described above.

When --min-group-size is supplied with --nogentotype, the maximum difference between the sample groups' average observation ratios is computed twice, between N members of sample group 1 and M members of sample group 2.  When comparing sample groups, the maximum difference is determined by taking the greater difference of 2 comparisons: 1. the top N observation ratios of sample group 1 versus the bottom M (inverse) observation ratios of sample group 2.  2. the bottom N observation ratios of sample group 1 versus top M observation ratios of sample group 2.  In order to avoid meaningless results, either N or M must represent a majority of their respective sample groups.  It is recommended to always set -d to the group size for 1 of the 2 groups.  --min-group-size should only be used when the groups being compared are not 2 sets of replicates.

When --min-group-size is supplied with --gentotype, the maximum difference between the sample groups' is computed in the same manner as described above for --genotype, except calls within a sample group are allowed to differ as long as there exists a subgroup of at least size --min-group-size with a consistent genotype call.

DYNAMIC CREATION OF SAMPLE GROUPS

When pairs of sample groups are not supplied, sample groups are greedily determined on each row independently.  Up to 2 --min-group-size's can be supplied, but must not sum to more than the number of samples.  The default minimum group sizes are both 1.  Sorting is performed in the same manner, except (in the case of --nogenotype) the top N and bottom M samples compared are selected from a single list.  In the case of --genotype, the samples are ordered by genotype call abundance and assigned to the groups from either end (omitting those with no-calls).

GROWING SAMPLE GROUPS FROM THE MINIMUM GROUP SIZE

If you have supplied a --min-group-size that is less than the number of samples defined in the group, you can allow sample groups to grow using the --grow parameter.  This allows you to identify groups of different (i.e. non-replicate) samples that share a difference with the comparison group.  Growing groups behaves differently depending on whether --genotype or --nogenotype is supplied.

If --nogenotype is supplied, grow groups is done using the --separation-gap threshold.  It uses the difference in the obervation ratio of 1 group and its inverse observation ratio in the comparison group.  For example, if you supply `--grow --nogenotype --separation-gap 0.5`, samples will be greedily* added to the 2 groups in order of their difference with the current group's observation ratio average and stops just before the difference in the averages crosses the threshold of 0.5.

If --genotype is supplied, all members of a sample group matching a genotype call in the sample group of size --min-group-size are added to the group.  If sample groups are being created dynamically and the groups have genotype calls in common, no other samples of the common genotype call will be added.

* Sample groups are seeded with members from either the bottom or top set of observation ratios.  Samples in different groups are seeded from opposite ends (top or bottom).  Samples are then traversed top-down or bottom-up and greedily added to the respective sample group in order of ascending difference from the current group average.

FILTERING

There are 2 threshold options that can be used to filter variants that do not contain differences between the sample groups that meet the thresholds.  In --genotype mode, the threshold is --min-group-size.  In --nogenotype mode the threshold is the combination of --separation-gap and --min-group-size.

In --nogenotype mode, if the difference between the observation ratios between (all of the*) pairs of sample groups is less than the separation gap threshold, the row will not be printed.

In --genotype mode, if the (all of the*) pairs of sample groups share a common genotypoe call, the row will not be printed.

* In either case, if any pair of sample groups meets the threshold(s), the row will be printed regardless of whether or not any other pair fails the threshold(s).

EXAMPLE

To sort based on the difference between specific samples or groups of samples, those groups can be defined on the command line using -s.  You can specify a minimum number of samples in the groups to differ.  So for example, say you have 3 wildtype (WT) replicates and you would like to see differences that all 3 WT samples have with any one of a set of 10 mutant samples.  You would do that on the command line using the sample names:

    -s "wt1 wt2 wt3" -d 3   -s "m1 m2 m3 m4 m5 m6 m7 m8 m9 m10" -d 1

The largest difference that the average observation ratio of the WT samples has with 1 of the mutant samples will be at the top of the results.

END_AHELP
	     );

setDefaults(HEADER        => 1,
	    ERRLIMIT      => 3,
	    COLLISIONMODE => 'error',
	    DEFRUNMODE    => 'usage',
	    DEFSDIR       => undef);

my $format_index            = 8;
my $sample_name_start_index = $format_index + 1;

my $vcf_type_id =
  addInfileOption(GETOPTKEY   => 'i|vcf-file',
		  REQUIRED    => 1,
		  PRIMARY     => 1,
		  DEFAULT     => undef,
		  SMRY_DESC   => 'VCF input file.',
		  DETAIL_DESC => ('VCF input file generated either by ' .
				  'freeBayes or svTyper.'),
		  FORMAT_DESC => << 'END_FORMAT'

A VCF file is a plain text, tab-delimited file.  The format is generally described here: http://bit.ly/2sulKcZ and described in detail here: http://bit.ly/2gKP5bN

However, the important parts that this script relies on are:

1. The column header line (in particular - looking for the FORMAT and sample name columns).
2. The colon-delimited codes in the FORMAT column values, specifically (for SNP data produced by freeBayes and Structural Variant data produced by SVTyper) AO (the number of reads supporting the variant), RO (the number of reads supporting the reference), and DP (the number of reads that map at or over the variant position).
3. The colon-delimited values in the sample columns that correspond to the positions defined in the FORMAT column.

The file may otherwise be a standard VCF file containing header lines preceded by '##'.  Empty lines are OK and will be printed regardless of parameters supplied to this script.  Note, the --header and --no-header flags of this script do not refer to the VCF file's header, but rather the run info header of this script.

END_FORMAT
		 );

my $vcf_oid =
  addOutfileSuffixOption(GETOPTKEY   => 'o|vcf-outfile-suffix',
			 PRIMARY     => 0,
			 DEFAULT     => undef,
			 SMRY_DESC   => 'VCF outfile suffix (appended to -i).',
			 FORMAT_DESC => ('The output file is the same format ' .
					 'as the input VCF files, except ' .
					 'sorted differently and possibly ' .
					 'filtered.'));

my $sum_oid =
  addOutfileSuffixOption(GETOPTKEY   => 'u|summary-outfile-suffix',
			 PRIMARY     => 1,
			 DEFAULT     => undef,
			 SMRY_DESC   => ('Summary outfile suffix (appended ' .
					 'to -i).'),
			 DETAIL_DESC => ('Summary outfile suffix (appended ' .
					 'to -i).  This file will contain a ' .
					 'row for each variant row in the ' .
					 'input VCF file, and include the ' .
					 'sorting value and pairs of sample ' .
					 'groups that were identified as ' .
					 'different.'),
			 FORMAT_DESC => << 'END_FORMAT'

Tab delimited file describing the sorting, filtering, and differing sample groups.  The columns of the file are:

    Chromosome - The chromosome on which the variant is located.
    Position - The position starting from 1 where the variant is located.
    Reference Value - The value the reference has in the variant position.
    Sort Value - The value the sorting of the file is based on, which is the maximum "Pair Sort Value".
    Pair Number - A colon-delimited list of numbers indicating the pair of sample groups the sort and filtering is based on.
    Pair Sort Value - This is a colon-delimited list of each pair's maximum difference between sample group 1 & 2.
    Most Differing Variant State - A colon-delimited list of each pair's most differing variant value (e.g. SNP value 'A') which the sort value is based on (because it differs the most between the 2 sample groups in the corresponding pair).  E.g. One group's samples have 'A' and the other group's samples have something *other than an 'A'*.
    Sample Group 1 Members - A colon-delimited list of each pair's comma-delimited group 1 sample names that were used to produce the sort value by determining their maximum difference.  E.g. For 2 pairs, the value might be: "s1,s2:s6,s7".
    Sample Group 1 Values - A colon-delimited list of pairs' group 1 comma-delimited values that were used to compute the corresponding "Pair Sort Value".  These may be a series of 0's and 1's indicating whether the sample's genotype is unique to group 1 or they are the observation ratios (in the form "numerator/denominator") of the selected variant state, chosen to differ most between sample groups.
    Sample Group 2 Members - A colon-delimited list of each pair's comma-delimited group 2 sample names that were used to produce the sort value by determining their maximum difference.  E.g. For 2 pairs, the value might be: "s3,s4,s5:s8,s9,s10".
    Sample Group 2 Values - A colon-delimited list of pairs' group 2 comma-delimited values that were used to compute the corresponding "Pair Sort Value".  These may be a series of 0's and 1's indicating whether the sample's genotype is unique to group 1 or they are the observation ratios (in the form "numerator/denominator") of the selected variant state, chosen to differ most between sample groups.

END_FORMAT
			);

my $sample_groups = [];
add2DArrayOption(GETOPTKEY   => 's|sample-group',
		 TYPE        => 'string',
		 GETOPTVAL   => $sample_groups,
		 DEFAULT     => 'any^',
		 SMRY_DESC   => ('A group of sample names for difference ' .
				 'comparisons.  ^ See --extended usage.'),
		 DETAIL_DESC => << 'END_DETAIL'

This option must be supplied an even number of times (or once* or 0 times**).  Each pair of samples groups, in order, is compared to determine the maximum difference between the groups.  For example, if you have 3 wildtype samples and 4 mutant samples, you can define these 2 groups using -s 's1 s2 s3' -s 's4 s5 s6 s7' (where sample name 's1', 's2', and 's3' are the wildtype samples and 's4', 's5', 's6', and 's7' are mutant samples.  (All sample names must match the sample names in the VCF column headers row.)  The differences in variant states between these groups of samples will be used to sort the variants/rows of the VCF file.  See --extended --help for a description of how degree of difference is calculated.

^ If no sample groups are supplied, a default pair of samples that are the most different on any particular row will be chosen.
* If only one group is defined, the second group is assumed to be the remainder of the samples.
** If no groups are defined, groups are dynamically determined for each variant/row.  See --help --extended for details.

END_DETAIL
		);

my $group_diff_mins = [];
addArrayOption(GETOPTKEY   => 'd|min-group-size',
	       TYPE        => 'integer',
	       GETOPTVAL   => $group_diff_mins,
	       DEFAULT     => 'all',
	       SMRY_DESC   => ('The minimum number of samples required to ' .
			       'differ from the partner group (to get a high ' .
			       'rank).'),
	       DETAIL_DESC => << 'END_DETAIL'

Each sample group defined by -s is accompanied by a (minimum) number of samples in that group with which to compute the maximum difference against its partner group.  Each instance of -s should have a -d value supplied.  The order of the -d values should correspond to the order of the -s sample groups they apply to.  The default for each group is the group size, but a smaller number can bespecified.  The purpose is best shown by example.  If you have 5 mutant samples and 3 replicate wildtype samples, you may want to find variants where 1 or more mutants differ from all 3 wildtype samples, thus -d for the mutant group would be '1' and -d for the wildtype group would be '3'.  In order to produce meaningful results, one group in each pair of groups must get a value that is larger than half the group size.  See --help --extended for details on how this affects variant sorting, sample group growing, and filtering.

END_DETAIL
		);

my $separation_gap = 0.6;
addOption(GETOPTKEY   => 'a|separation-gap',
	  TYPE        => 'float',
	  GETOPTVAL   => \$separation_gap,
	  DEFAULT     => $separation_gap,
	  SMRY_DESC   => ("Allelic frequency difference threshold [0-1]."),
	  DETAIL_DESC => ('The maximum difference between average ' .
			  'observation ratios for a given variant state ' .
			  '(e.g. a SNP value of "A") between groups defined ' .
			  'by -s (and -d) must be at least this value in ' .
			  'order to either be retained (see --filter|' .
			  '--nofilter) or grown (--grow|--nogrow).  This ' .
			  'option is only used when either --filter or ' .
			  '--grow are true.  See --help --extended for more ' .
			  'details.'));

my $genotype = 1;
addOption(GETOPTKEY   => 'g|genotype',
	  TYPE        => 'negbool',
	  GETOPTVAL   => \$genotype,
	  DEFAULT     => $genotype,
	  SMRY_DESC   => ("Use or don't use genotype calls."),
	  DETAIL_DESC => ("Use or don't use the genotype call (i.e. the 'GT' " .
			  'value in the FORMAT string) for sorting rows, ' .
			  'growing sample groups, and filtering rows (see ' .
			  '--filter).  If --nogenotype is supplied, only ' .
			  'allelic frequencies will be used for these ' .
			  'functions.  See --help --extended for details.'));

my $filter = 1;
addOption(GETOPTKEY   => 'f|filter',
	  TYPE        => 'negbool',
	  GETOPTVAL   => \$filter,
	  DEFAULT     => $filter,
	  SMRY_DESC   => ("Filter or don't filter variant rows whose sample " .
			  "groups do not differ (enough)."),
	  DETAIL_DESC => ("Filter or don't filter variant rows whose sample " .
			  'group pairs do not meet thresholds defined by ' .
			  'either `--genotype --min-group-size <int>` or ' .
			  '`--nogenotype --min-group-size <int> --separation-' .
			  'gap <float>`.  When --genotype is supplied, the ' .
			  'genotype calls in all samples in each minimum ' .
			  'group must not have any common genotype calls and ' .
			  'meet the minimum size requirement.  When ' .
			  '--nogenotype is supplied, the difference in ' .
			  'average observation ratios must be greater than ' .
			  'or equal to the --separation-gap.  See --help ' .
			  '--extended for more details.'));

my $grow = 1;
addOption(GETOPTKEY   => 'w|grow',
	  TYPE        => 'negbool',
	  GETOPTVAL   => \$grow,
	  DEFAULT     => $grow,
	  SMRY_DESC   => ('Add as many samples to sample groups as possible.'),
	  DETAIL_DESC => ('If the --min-group-size is less than the actual ' .
			  'sample group size, keep adding samples to the ' .
			  'minimum groups (from its remaining members) as ' .
			  'long as (if --nogenotype is supplied) the ' .
			  'difference in average observation ratios between ' .
			  'the groups is greater than -a or (if --genotype ' .
			  'is supplied) the genotype call is the same as ' .
			  'current members and different from all partner ' .
			  'group genotypes.  Note, this may lower the sort ' .
			  'order of a variant/row when --nogenotype is ' .
			  'supplied.'));

processCommandLine();

#There must be an even number of sample groups (or 1)
if(scalar(@$sample_groups) % 2 && scalar(@$sample_groups) != 1)
  {
    error("There must be an even number of sample groups (or 1), but [",
	  scalar(@$sample_groups),"] were supplied.  See the usage ",
	  "description for -s for details.",
	  {DETAIL => ('Groups are submitted in pairs and the difference in ' .
		      'their average observation ratios is used for sorting, ' .
		      'filtering, and growing.  If 1 is supplied, the second ' .
		      'group is automatically populated with the remainder')});
    quit(1);
  }

#Construct default values for the group_diff_mins if they weren't all supplied
if(scalar(@$sample_groups) &&
   scalar(@$sample_groups) > scalar(@$group_diff_mins))
  {
    my $all = (scalar(@$group_diff_mins) == 0);
    foreach my $sample_group_index (0..$#{$sample_groups})
      {
	if(scalar(@$group_diff_mins) < ($sample_group_index + 1))
	  {
	    if($all || ($group_diff_mins->[0] >
			scalar(@{$sample_groups->[$sample_group_index]})))
	      {$group_diff_mins->[$sample_group_index] =
		 scalar(@{$sample_groups->[$sample_group_index]})}
	    else
	      {$group_diff_mins->[$sample_group_index] = $group_diff_mins->[0]}
	  }
      }
  }

if(scalar(@$group_diff_mins) && scalar(@$sample_groups))
  {
    #There must be an equal number of group diff mins
    if((scalar(@$sample_groups) > 2 &&
	scalar(@$group_diff_mins) != scalar(@$sample_groups)) ||
       (scalar(@$sample_groups) <= 2 && scalar(@$group_diff_mins) > 2))
      {
	error("-d must be supplied 0, 1, 2, or the same number of times as ",
	      "-s.");
	quit(2);
      }
    #The values of the group diff mins must be less than or equal to the
    #corresponding group sizes
    elsif(scalar(@$group_diff_mins) <= scalar(@$sample_groups) &&
	  scalar(grep {$group_diff_mins->[$_] < 1 ||
			 $group_diff_mins->[$_] >
			   scalar(@{$sample_groups->[$_]})}
		 (0..$#{$group_diff_mins})))
      {
	error("The min group size (-d) [",join(',',@$group_diff_mins),
	      "] must be a positive value greater than 0 and less than or ",
	      "equal to the number of members in the corresponding sample ",
	      "group [",join(',',map {scalar(@$_)} @$sample_groups),"].  ",
	      "Unable to proceed.");
	quit(3);
      }
  }

#If this is the special case of 1 group (and possibly 2 min diff sizes)
if(scalar(@$sample_groups) == 1)
  {
    #If there are 2 min diff sizes, the first must represent the majority of its
    #group
    if(scalar(@$group_diff_mins) >= 1 &&
       $group_diff_mins->[0] <= (scalar(@{$sample_groups->[0]}) / 2))
      {
	error("When 1 sample group is supplied (implying that the second ",
	      "sample group is the remainder of the samples) and a min group ",
	      "size is supplied, the first size must represent a majority of ",
	      "the group size.");
	quit(4);
      }
  }
#NOTE: One of the group_diff_mins in each pair must represent a majority of the
#corresponding group
elsif(scalar(@$sample_groups) &&
      scalar(grep {($group_diff_mins->[$_] >
		    (scalar(@{$sample_groups->[$_]}) / 2)) ||
		      ($group_diff_mins->[$_ + 1] >
		       (scalar(@{$sample_groups->[$_ + 1]}) / 2))}
	     grep {$_ % 2 == 0} (0..$#{$sample_groups})) == 0)
  {
    error("One of each pair of group diff mins (-d) must represent a ",
	  "majority of the number of members in its corresponding sample ",
	  "group.",
	  {DETAIL => "One group must serve as an unambiguous reference " .
	   "genotype.  It can be a single sample or a set of replicate " .
	   "samples.  This makes the results more interpretable."});
    quit(5);
  }

if($separation_gap < 0 || $separation_gap > 1)
  {
    error("Invalid value for -a [$separation_gap].  Must be between 0 and 1 ",
	  "(inclusive).");
    quit(6);
  }

my $global_mode = '';

while(nextFileCombo())
  {
    my $inputFile  = getInfile();
    my $outputFile = getOutfile($sum_oid);
    my $vcfoutFile = getOutfile($vcf_oid);

    openIn(*IN,$inputFile)     || next;

    my $line_num  = 0;
    my @samples   = ();
    my $data_line = 0;
    my $outputs   = {HEADER_LINES  => '',
		     COMMENT_LINES => '',
		     ROW_DATA      => []};

    while(getLine(*IN))
      {
	$line_num++;

	#If this is a header line that is not the (first) column header line
	if(/^##/)
	  {
	    if(defined($vcfoutFile) && /^#/)
	      {$outputs->{HEADER_LINES} .= $_}
	    next;
	  }
	elsif(scalar(@samples) && /^#/)
	  {
	    if(defined($vcfoutFile) && /^#/)
	      {$outputs->{COMMENT_LINES} .= $_}
	    next;
	  }
	elsif(/^\s*$/)
	  {next}

	chomp;
	my @cols = split(/\t/,$_,-1);

	#If this is the (first) column header line
	if(/^#[^#].*\t/ && scalar(@samples) == 0)
	  {
	    #Get the index of the FORMAT column - we will assume that the
	    #sample columns start immediately after and go to the end
	    if(/\tFORMAT\t/)
	      {
		#Assuming only 1 FORMAT column header
		$format_index = (grep {$cols[$_] eq 'FORMAT'} (0..$#cols))[0];
		$sample_name_start_index = $format_index + 1;
	      }
	    else
	      {
		warning("FORMAT column header not found on column header ",
			"line.  Using default expected FORMAT column number [",
			($format_index + 1),"] and sample column start ",
			"number [",($sample_name_start_index + 1),"].");
	      }

	    #If -s was supplied, the sample names in the column header are
	    #necessary - otherwise, we can assume that the header is just
	    #malformed and that the samples are where we would otherwise expect
	    #them to be in a standard VCF file (as produced by FreeBayes).
	    if(scalar(@samples) &&
	       scalar(@cols) < ($sample_name_start_index + 1))
	      {
		error("No columns for sample names were found on the ",
		      "column header line: [$_].  Unable to finish ",
		      "processing file [$inputFile].",
		      {DETAIL => "Sample names in the column header are " .
		       "used to identify sample columns for use with the -s " .
		       "and -d parameters, and to find the number of " .
		       "supporting read and total reads for each record.  " .
		       "If your column header line is malformed, but the " .
		       "data is there and you do not supply -s or -d, you " .
		       "will still be able to proceed using the default " .
		       "FORMAT column number [",($format_index + 1),"] and " .
		       "sample column start number [",
		       ($sample_name_start_index + 1),"]."});

		last;
	      }

	    @samples = @cols[$sample_name_start_index..$#cols];
	    s/#//;

	    if(scalar(@samples) < 2)
	      {
		error("A column header line with more than 1 sample name ",
		      "after the FORMAT column is required.  Skipping file ",
		      "[$inputFile].",
		      {DETAIL => ('The purpose of this script is to compare ' .
				  'samples, which requires more than 1 ' .
				  'sample be present in the file.')});
		last;
	      }
	    if(scalar(grep {$_ eq ''} @samples))
	      {
		error("Empty sample names encountered on column header row ",
		      "after the FORMAT column.  Skipping file [$inputFile].",
		      {DETAIL => ('Sample names are used in the output ' .
				  'format of this script for identification ' .
				  'of sample groups, thus they must all have ' .
				  'values.')});
		last;
	      }

	    #Validate the sample names in the groups
	    if(scalar(@$sample_groups))
	      {unless(validateSampleGroupNames(\@samples,$sample_groups))
		 {quit(7)}}

	    #Handle a special case where auto-group creation is allowed
	    if(scalar(@$sample_groups) == 1)
	      {
		#Validate that there are enough samples to create a second group
		if(scalar(@{$sample_groups->[0]}) >= scalar(@samples))
		  {
		    error("Not enough samples [",scalar(@samples),"] to auto-",
			  "create second sample group (-s), given the first ",
			  "sample group size of [",
			  scalar(@{$sample_groups->[0]}),"].");
		    quit(8);
		  }

		#Create the second group
		push(@$sample_groups,
		     [grep {my $n=$_;
			    scalar(grep {$_ eq $n} @{$sample_groups->[0]}) == 0}
		      @samples]);

		#Validate any existing group diff min
		if(scalar(@$group_diff_mins) == scalar(@$sample_groups))
		  {
		    if($group_diff_mins->[1] > scalar(@{$sample_groups->[1]}) ||
		       $group_diff_mins->[1] < 1)
		      {
			error("Invalid min group size (-d) [",
			      $group_diff_mins->[1],"] for sample group of ",
			      "size [",scalar(@{$sample_groups->[1]}),"].");
			quit(9);
		      }
		  }
		#Add a new group diff min
		else
		  {push(@$group_diff_mins,scalar(@{$sample_groups->[1]}))}
	      }

	    #If there's not at least 2 min group sizes
	    if(scalar(@$group_diff_mins) < 2)
	      {
		#If there's 1 min group size, compute the size of the second one
		if(scalar(@$group_diff_mins))
		  {push(@$group_diff_mins,
			scalar(@samples) - $group_diff_mins->[0])}
		else
		  {push(@$group_diff_mins,1,1)}
	      }

	    #Print the new header
	    $outputs->{HEADER_LINES} .= "#$_\n";

	    next;
	  }
	elsif(scalar(@samples) == 0)
	  {
	    warning("Column header line not found before data.  Using ",
		    "default expected FORMAT column number [",
		    ($format_index + 1),"] and sample column start number [",
		    ($sample_name_start_index + 1),"].");
	  }

	if(scalar(@cols) < ($sample_name_start_index + 1))
	  {
	    error("Sample data was not found on line: [$line_num] of VCF ",
		  "file [$inputFile].  Skipping line.",
		  {DETAIL => "Sample names in the column header are " .
		   "used to identify sample columns for use with the -s " .
		   "and -d parameters, and to find the number of " .
		   "supporting read and total reads for each record.  " .
		   "If your column header line is malformed, but the " .
		   "data is there and you do not supply -s or -d, you " .
		   "will still be able to proceed using the default " .
		   "FORMAT column number [",($format_index + 1),"] and " .
		   "sample column start number [",
		   ($sample_name_start_index + 1),"]."});

	    next;
	  }

	$data_line++;

	my $format_str = $cols[$format_index];
	my(@data)      = @cols[$sample_name_start_index..$#cols];

	debug("FORMAT string for data record [$data_line]: [$format_str].");

	#Determine the subindex of each piece of sample data based on the
	#FORMAT string by creating a hash
	my $format_subindex = 0;
	my $format_key_tosubindex = {};
	foreach my $key (split(/:/,$format_str,-1))
	  {$format_key_tosubindex->{$key} = $format_subindex++}

	if($genotype && !exists($format_key_tosubindex->{GT}))
	  {
	    error("Line [$line_num] does not contain the required tag [GT] ",
		  "(for running in --genotype mode) in the FORMAT column.  ",
		  "Skipping.");
	    next;
	  }
	elsif(!$genotype && scalar(grep {!exists($format_key_tosubindex->{$_})}
				   ('AO','RO','DP')))
	  {
	    error("Line [$line_num] does not contain the required tags [",
		  join(',',grep {!exists($format_key_tosubindex->{$_})}
		       ('AO','RO','DP')),
		  "] (for running in --nogenotype mode) in the FORMAT ",
		  "column.  Skipping.");
	    next;
	  }

	#Parse the sample info from all the sample columns
	my $sample_info = {};
	foreach my $format_subindex (0..$#samples)
	  {
	    #If there is no data for this sample (i.e. no reads mapped over the
	    #position of this variant)
	    if($data[$format_subindex] eq '.')
	      {
		#Create a bogus record so GT, DP, RO, & AO can be set to ./0
		$data[$format_subindex] =
		  '.:' . '0:'x(scalar(keys(%$format_key_tosubindex)) - 1);
		chop($data[$format_subindex]);
	      }

	    #Get the sample name for this sample column
	    my $sample = $samples[$format_subindex];

	    #Get the data specific to this sample
	    my @d = split(/:/,$data[$format_subindex],-1);

	    debug("Data for sample [$sample]: [",join(':',@d),"].",
		  {LEVEL => 3});

	    #Create easy access to the sample info by creating a hash like:
	    #sample_info->{$samplename}->{GT} = value
	    $sample_info->{$samples[$format_subindex]} =
	      {map {$_ => $d[$format_key_tosubindex->{$_}]}
	       keys(%$format_key_tosubindex)};
	  }

	#Quick error check.  There must be either 0 or scalar(@$group_diff_mins)
	#sample groups
	if(scalar(@$sample_groups) != 0 &&
	   scalar(@$sample_groups) != scalar(@$group_diff_mins))
	  {
	    error("Invalid number of sample groups: [",scalar(@$sample_groups),
		  "].  Must be the same as the number of minimum group sizes ",
		  "(see -d).  Unable to proceed.");
	    quit(10);
	  }

	my @tmp_sample_groups = @$sample_groups;
	#If the sample groups have not been created, initialize them
	if(scalar(@tmp_sample_groups) == 0)
	  {@tmp_sample_groups = createSampleGroups($sample_info,
						   $group_diff_mins)}

	if(scalar(@tmp_sample_groups) == 0)
	  {
	    error("No sample groups.",{DETAIL => "Line $line_num"});
	    next;
	  }

	my $anything_passed = 0;
	my $group_pair_rule = 0;
	my $rank_data       = [];
	my $best_score      = -1;
	my $best_dp         = 0;
	my $best_pair       = '.';
	foreach my $pair_index (grep {$_ % 2 == 0} (0..$#tmp_sample_groups))
	  {
	    $group_pair_rule++;
	    my $set1     = [@{$tmp_sample_groups[$pair_index]}];
	    my $set1_min = $group_diff_mins->[$pair_index];
	    my $set2     = [@{$tmp_sample_groups[$pair_index + 1]}];
	    my $set2_min = $group_diff_mins->[$pair_index + 1];

	    debug("$_\nSET1: [",join(',',@$set1),"] SET1MIN: $set1_min ",
		  "SET2: [",join(',',@$set2),"] SET2MIN: $set2_min",
		  {LEVEL => 2});

	    my($min_group1,$min_group2,$real_remainders1,$real_remainders2,
	       $leftright_case) =
	      createMinSampleGroupPair($set1,$set1_min,
				       $set2,$set2_min,
				       $sample_info);

	    debug("Testing groups [",
		  (defined($min_group1) ?
		   join(',',map {defined($_) ? $_ : 'undef'} @$min_group1) :
		   'undef array'),"] vs [",
		  (defined($min_group2) ?
		   join(',',map {defined($_) ? $_ : 'undef'} @$min_group2) :
		   'undef array'),"] with remainders [@$real_remainders1] and ",
		  "[@$real_remainders2] and left/right case: [$leftright_case",
		  "].");

	    if(!$filter || sampleGroupPairPasses($min_group1,$min_group2,
						 $sample_info))
	      {
		$anything_passed++;
		if($grow && (scalar(@$min_group1) < scalar(@$set1) ||
			     scalar(@$min_group2) < scalar(@$set2)))
		  {growAPair($min_group1,$min_group2,
			     $real_remainders1,$real_remainders2,
			     $leftright_case,$sample_info)}
		my $scoring_data = getBestScoringData($min_group1,
						      $min_group2,
						      $sample_info);
		if($scoring_data->{RANK} > $best_score)
		  {
		    $best_score = $scoring_data->{RANK};
		    $best_dp    = $scoring_data->{AVEDP};
		    $best_pair  = $group_pair_rule;
		  }
		push(@$rank_data,
		     {RULE_NUM => $group_pair_rule,            #int
		      SAMPLES1 => $min_group1,                 #array ref
		      SAMPLES2 => $min_group2,                 #array ref
		      SCORE    => $scoring_data->{RANK},       #dec
		      SUBSCORE => $scoring_data->{AVEDP},      #num
		      STATE    => $scoring_data->{STATE},      #str
		      SCORES1  => $scoring_data->{SCORES1},    #array ref
		      SCORES2  => $scoring_data->{SCORES2}});  #array ref
	      }
	  }

	if($anything_passed)
	  {
	    push(@{$outputs->{ROW_DATA}},
		 {VCF_LINE  => "$_\n",
		  CHROM     => $cols[0],
		  POS       => $cols[1],
		  ID        => $cols[2],
		  REF       => $cols[3],
		  ALT       => $cols[4],
		  BEST_PAIR => $best_pair,
		  RANK      => $best_score,
		  AVEDP     => $best_dp,
		  RANK_DATA => $rank_data});
	  }
      }

    closeIn(*IN);

    if(scalar(@{$outputs->{ROW_DATA}}))
      {
	openOut(*OUT,$outputFile);
	openOut(HANDLE => *VCFO,
		FILE   => $vcfoutFile,
		HEADER => 0);

	if(defined($vcfoutFile))
	  {print VCFO ($outputs->{HEADER_LINES})}

	print OUT ("#CHROM\tPOS\tID\tREF\tALT\tBEST_PAIR\tBEST_SEP_SCORE\t",
		   "BEST_AVEDP\tPAIR_NUM\tPAIR_SEP_SCORE\tPAIR_AVEDP\t",
		   "STATE(S)_USED\tPAIR1_MEMBERS\tPAIR1_SCORE_DATA\t",
		   "PAIR2_MEMBERS\tPAIR2_SCORE_DATA\n");

	foreach my $ordered_rec (sort {compareWhenZero($b->{AVEDP},$a->{AVEDP})
					 || compareDec($b->{RANK},$a->{RANK}) ||
					   $b->{AVEDP} <=> $a->{AVEDP}}
				 @{$outputs->{ROW_DATA}})
	  {
	    #Print the VCF output
	    if(defined($vcfoutFile))
	      {print VCFO ($ordered_rec->{VCF_LINE})}

	    #Code for debugging
	    my $teststate =
	      join(':',map {$_->{STATE}} @{$ordered_rec->{RANK_DATA}});
	    if($teststate =~ /\d/ && intRound($ordered_rec->{AVEDP}) == 0)
	      {warning("AVEDP of 0 when state has a value: [$teststate].")}

	    #Print the rank info
	    print OUT (join("\t",($ordered_rec->{CHROM},$ordered_rec->{POS},
				  $ordered_rec->{ID},$ordered_rec->{REF},
				  $ordered_rec->{ALT},$ordered_rec->{BEST_PAIR},
				  sigdec($ordered_rec->{RANK},4),
				  intRound($ordered_rec->{AVEDP}))),"\t",
		       #Next column's a colon-delimited list of passing rule 
		       #numbers
		       join(':',map {$_->{RULE_NUM}}
			    @{$ordered_rec->{RANK_DATA}}),"\t",
		       #Next column is a colon-delimited list of each rule's
		       #score
		       join(':',map {sigdec($_->{SCORE},4)}
			    @{$ordered_rec->{RANK_DATA}}),"\t",
		       #Next column is a colon-delimited list of each rule's
		       #sub-score (which is the average DP (read depth))
		       join(':',map {intRound($_->{SUBSCORE},4)}
			    @{$ordered_rec->{RANK_DATA}}),"\t",
		       #Next column's a colon-delimited list of each rule's
		       #state(s).  For 'nogenotype', states are a single
		       #nucleotide character.  For genotype, states are 2 lists
		       #of unique genotype calls in sample groups 1 & 2.  Calls
		       #are delimited by "+" and groups are delimited by ";"
		       join(':',map {$_->{STATE}} @{$ordered_rec->{RANK_DATA}}),
		       "\t",
		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of samples in group 1
		       join(':',(map {join(',',@{$_->{SAMPLES1}})}
				 @{$ordered_rec->{RANK_DATA}})),"\t",
		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of scores in group 1
		       join(':',(map {join(',',@{$_->{SCORES1}})}
				 @{$ordered_rec->{RANK_DATA}})),"\t",
		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of samples in group 2
		       join(':',(map {join(',',@{$_->{SAMPLES2}})}
				 @{$ordered_rec->{RANK_DATA}})),"\t",
		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of scores in group 2
		       join(':',(map {join(',',@{$_->{SCORES2}})}
				 @{$ordered_rec->{RANK_DATA}})),"\n");
	  }

	if(defined($vcfoutFile))
	  {print VCFO ($outputs->{COMMENT_LINES})}

	closeOut(*VCFO);
	closeOut(*OUT);
      }
  }


#If one or the other value is zero, sort by their values, otherwise return 0 to
#allow the sort to be based on the next thing
sub compareWhenZero
  {
    my $left  = $_[0];
    my $right = $_[1];

    if($left == 0 || $right == 0)
      {return($left <=> $right)}

    return(0);
  }

sub growAPair
  {
    my $min_group1       = $_[0];
    my $min_group2       = $_[1];
    my $real_remainders1 = $_[2];
    my $real_remainders2 = $_[3];
    my $leftright_case   = $_[4]; #Whether group 1 should grow from the left and
                                  #2 from the right or vice versa
    my $sample_info      = $_[5];

    my($something_added);

    $something_added = 1;
    while($something_added && scalar(@$real_remainders1))
      {
	$something_added = 0;
	my $next_sample = ($leftright_case ?
			   shift(@$real_remainders1) :
			   pop(@$real_remainders1));
	if(sampleGroupPairPasses([@$min_group1,$next_sample],
				 $min_group2,
				 $sample_info))
	  {
	    push(@$min_group1,$next_sample);
	    $something_added = 1;
	  }
      }
    $something_added = 1;
    while($something_added && scalar(@$real_remainders2))
      {
	$something_added = 0;
	my $next_sample = ($leftright_case ?
			   pop(@$real_remainders2) :
			   shift(@$real_remainders2));
	if(sampleGroupPairPasses($min_group1,
				 [@$min_group2,$next_sample],
				 $sample_info))
	  {
	    push(@$min_group2,$next_sample);
	    $something_added = 1;
	  }
      }
  }


sub createMinSampleGroupPair
  {
    my $max_group1  = $_[0];
    my $min_size1   = $_[1];
    my $max_group2  = $_[2];
    my $min_size2   = $_[3];
    my $sample_info = $_[4];

    my $min_group1      = [];
    my $min_group2      = [];
    my $real_remainder1 = []; #Holds remaining samples that have observations
    my $real_remainder2 = [];
    my $case_leftright  = 1;  #Whether we added to 1 from the left and 2 / right

    ##
    ## The following code differs from that in createSampleGroups because this
    ## version takes a single pair of sample groups and creates a minimum group
    ## out of each whereas createSampleGroups takes a list of pair sizes and
    ## builds maximum sample groups from a single sample list
    ##

    if($genotype)
      {
	##
	## Figure out which min group of 2 possibilities is better
	##

	#Determine the overall genotype counts
	my $genotype_counts = {};
	foreach my $sample (keys(%$sample_info))
	  {$genotype_counts->{$sample_info->{$sample}->{GT}}++}

	#Establish the ordering of the samples of max group 1 by genotype
	#abundance
	my @ordered_samples_real1 =
	  sort {$genotype_counts->{$sample_info->{$b}->{GT}} <=>
		  $genotype_counts->{$sample_info->{$a}->{GT}} ||
		    $sample_info->{$a}->{GT} <=> $sample_info->{$b}->{GT}}
	    grep {$sample_info->{$_}->{GT} !~ /\./} @$max_group1;
	my @nocalls1 = grep {$sample_info->{$_}->{GT} =~ /\./} @$max_group1;

	#Establish the ordering of the samples of max group 2 by genotype
	#abundance
	my @ordered_samples_real2 =
	  sort {$genotype_counts->{$sample_info->{$b}->{GT}} <=>
		  $genotype_counts->{$sample_info->{$a}->{GT}} ||
		    $sample_info->{$a}->{GT} <=> $sample_info->{$b}->{GT}}
	    grep {$sample_info->{$_}->{GT} !~ /\./} @$max_group2;
	my @nocalls2 = grep {$sample_info->{$_}->{GT} =~ /\./} @$max_group2;

	#Case 1: left of group 1 versus right of group 2
	my @ordered_samples_real1_tmp = @ordered_samples_real1;
	my @nocalls1_tmp              = @nocalls1;
	my @ordered_samples_real2_tmp = @ordered_samples_real2;
	my @nocalls2_tmp              = @nocalls2;
	my $min_group1_case1          = [];
	push(@$min_group1_case1,shift(@ordered_samples_real1_tmp))
	  while(scalar(@$min_group1_case1) < $min_size1 &&
		scalar(@ordered_samples_real1_tmp));
	my $real_remainder1_case1 = [];
	if(scalar(@$min_group1_case1) >= $min_size1)
	  {@$real_remainder1_case1 = @ordered_samples_real1_tmp}
	push(@$min_group1_case1,shift(@nocalls1_tmp))
	  while(scalar(@$min_group1_case1) < $min_size1 &&
		scalar(@nocalls1_tmp));
	my $min_group2_case1 = [];
	push(@$min_group2_case1,pop(@ordered_samples_real2_tmp))
	  while(scalar(@$min_group2_case1) < $min_size2 &&
		scalar(@ordered_samples_real2_tmp));
	my $real_remainder2_case1 = [];
	if(scalar(@$min_group2_case1) >= $min_size2)
	  {@$real_remainder2_case1 = @ordered_samples_real2_tmp}
	push(@$min_group2_case1,shift(@nocalls2_tmp))
	  while(scalar(@$min_group2_case1) < $min_size2 &&
		scalar(@nocalls2_tmp));

	#Case 2: right of group 1 versus left of group 2
	@ordered_samples_real1_tmp = @ordered_samples_real1;
	@nocalls1_tmp              = @nocalls1;
	@ordered_samples_real2_tmp = @ordered_samples_real2;
	@nocalls2_tmp              = @nocalls2;
	my $min_group1_case2       = [];
	push(@$min_group1_case2,pop(@ordered_samples_real1_tmp))
	  while(scalar(@$min_group1_case2) < $min_size1 &&
		scalar(@ordered_samples_real1_tmp));
	my $real_remainder1_case2 = [];
	if(scalar(@$min_group1_case1) >= $min_size1)
	  {@$real_remainder1_case2 = @ordered_samples_real1_tmp}
	push(@$min_group1_case2,shift(@nocalls1_tmp))
	  while(scalar(@$min_group1_case2) < $min_size1 &&
		scalar(@nocalls1_tmp));
	my $min_group2_case2 = [];
	push(@$min_group2_case2,shift(@ordered_samples_real2_tmp))
	  while(scalar(@$min_group2_case2) < $min_size2 &&
		scalar(@ordered_samples_real2_tmp));
	my $real_remainder2_case2 = [];
	if(scalar(@$min_group2_case2) >= $min_size2)
	  {@$real_remainder2_case2 = @ordered_samples_real2_tmp}
	push(@$min_group2_case2,shift(@nocalls2_tmp))
	  while(scalar(@$min_group2_case2) < $min_size2 &&
		scalar(@nocalls2_tmp));

	#Determine which case is better (the one with more samples with a real
	#and unique genotype)
	my $g1_gts = {map {$sample_info->{$_}->{GT} => 1}
		      grep {$sample_info->{$_}->{GT} !~ /\./}
		      @$min_group1_case1};
	my $g2_gts = {map {$sample_info->{$_}->{GT} => 1}
		      grep {$sample_info->{$_}->{GT} !~ /\./}
		      @$min_group2_case1};
	my $common_nocall_gts =
	  {map {$_ => 1} grep {/\./ || exists($g2_gts->{$_})} keys(%$g1_gts)};
	my $unique_call_count_case1 = 0;
	foreach my $sample (grep {defined($_)}
			    (@$min_group1_case1,@$min_group2_case1))
	  {$unique_call_count_case1++
	     unless(exists($common_nocall_gts
			   ->{$sample_info->{$sample}->{GT}}))}

	$g1_gts = {map {$sample_info->{$_}->{GT} => 1}
		   grep {$sample_info->{$_}->{GT} !~ /\./}
		   @$min_group1_case2};
	$g2_gts = {map {$sample_info->{$_}->{GT} => 1}
		   grep {$sample_info->{$_}->{GT} !~ /\./}
		   @$min_group2_case2};
	$common_nocall_gts =
	  {map {$_ => 1} grep {/\./ || exists($g2_gts->{$_})} keys(%$g1_gts)};
	my $unique_call_count_case2 = 0;
	foreach my $sample (grep {defined($_)}
			    (@$min_group1_case2,@$min_group2_case2))
	  {$unique_call_count_case2++
	     unless(exists($common_nocall_gts
			   ->{$sample_info->{$sample}->{GT}}))}

	if($unique_call_count_case1 >= $unique_call_count_case2)
	  {
	    @$min_group1      = @$min_group1_case1;
	    @$min_group2      = @$min_group2_case1;
	    @$real_remainder1 = @$real_remainder1_case1;
	    @$real_remainder2 = @$real_remainder2_case1;
	    $case_leftright   = 1;
	  }
	else
	  {
	    @$min_group1      = @$min_group1_case2;
	    @$min_group2      = @$min_group2_case2;
	    @$real_remainder1 = @$real_remainder1_case2;
	    @$real_remainder2 = @$real_remainder2_case2;
	    $case_leftright   = 0;
	  }

	debug("Min group 1: [@$min_group1] Remainder 1: [@$real_remainder1]\n",
	      "Min group 2: [@$min_group2] Remainder 2: [@$real_remainder2].\n",
	      "Case: ",($case_leftright ? "left/right" : "right/left"),".",
	      {LEVEL => 2});
      }
    else #nogenotype mode
      {
	my($best_state,$best_leftright);
	my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);
	my @variant_states  = ('RO',@$ao_keys);
	my $remainder       = [];
	my $best_group1     = [];
	my $best_group2     = [];
	my $best_remainder1 = [];
	my $best_remainder2 = [];
	my $best_gap        = 0;

	foreach my $state (@variant_states)
	  {
	    my $tmp_group1_1    = [];#Case1: bottom of group 1 vs top of group 2
	    my $tmp_group2_1    = [];
	    my $tmp_group1_2    = [];#Case2: top of group 1 vs bottom of group 2
	    my $tmp_group2_2    = [];
	    my $remainder1_1    = [];
	    my $remainder2_1    = [];
	    my $remainder1_2    = [];
	    my $remainder2_2    = [];

	    my @ordered_observation_ratios1 =
	      sort {compareSampleObservationRatios($a,$b,$state,
						   $expanded_sample_info)}
		grep {$expanded_sample_info->{$_}->{DP}} @$max_group1;
	    my @no_observations1 = grep {!$expanded_sample_info->{$_}->{DP}}
	      @$max_group1;

	    my @ordered_observation_ratios2 =
	      sort {compareSampleObservationRatios($a,$b,$state,
						   $expanded_sample_info)}
		grep {$expanded_sample_info->{$_}->{DP}} @$max_group2;
	    my @no_observations2 = grep {!$expanded_sample_info->{$_}->{DP}}
	      @$max_group2;

	    my @ordered_observation_ratios1_tmp =
	      @ordered_observation_ratios1;
	    my @ordered_observation_ratios2_tmp =
	      @ordered_observation_ratios2;

	    #Try creating group 1 from the left and 2 from the right
	    push(@$tmp_group1_1,shift(@ordered_observation_ratios1_tmp))
	      while(scalar(@$tmp_group1_1) < $min_size1 &&
		    scalar(@ordered_observation_ratios1_tmp));
	    @$remainder1_1 = @ordered_observation_ratios1_tmp;
	    push(@$tmp_group1_1,shift(@no_observations1))
	      while(scalar(@$tmp_group1_1) < $min_size1 &&
		    scalar(@no_observations1));

	    push(@$tmp_group2_1,pop(@ordered_observation_ratios2_tmp))
	      while(scalar(@$tmp_group2_1) < $min_size2 &&
		    scalar(@ordered_observation_ratios2_tmp));
	    @$remainder2_1 = @ordered_observation_ratios2_tmp;
	    push(@$tmp_group2_1,shift(@no_observations2))
	      while(scalar(@$tmp_group2_1) < $min_size2 &&
		    scalar(@no_observations2));

	    my $ave1 = mean([map {$expanded_sample_info->{$_}->{$state} /
				    ($expanded_sample_info->{$_}->{DP} ?
				     $expanded_sample_info->{$_}->{DP} : 1)}
			     @$tmp_group1_1]);
	    my $ave2 = mean([map {$expanded_sample_info->{$_}->{$state} /
				    ($expanded_sample_info->{$_}->{DP} ?
				     $expanded_sample_info->{$_}->{DP} : 1)}
			     @$tmp_group2_1]);
	    my $gap1 = abs($ave1 - $ave2);
	    my $leftright = 1;


	    #Now try creating group 1 from the right and 2 from the left (if
	    #necessary)
	    if($min_size1 != scalar(@$max_group1) ||
	       $min_size2 != scalar(@$max_group2))
	      {
		#Try creating group 1 from the right and 2 from the left
		@ordered_observation_ratios1_tmp =
		  @ordered_observation_ratios1;
		@no_observations1 = grep {!$expanded_sample_info->{$_}->{DP}}
		  @$max_group1;

		@ordered_observation_ratios2_tmp =
		  @ordered_observation_ratios2;
		@no_observations2 = grep {!$expanded_sample_info->{$_}->{DP}}
		  @$max_group2;

		push(@$tmp_group1_2,pop(@ordered_observation_ratios1_tmp))
		  while(scalar(@$tmp_group1_2) < $min_size1 &&
		        scalar(@ordered_observation_ratios1_tmp));
		@$remainder1_2 = @ordered_observation_ratios1_tmp;
		push(@$tmp_group1_2,shift(@no_observations1))
		  while(scalar(@$tmp_group1_2) < $min_size1 &&
			scalar(@no_observations1));

		push(@$tmp_group2_2,shift(@ordered_observation_ratios2_tmp))
		  while(scalar(@$tmp_group2_2) < $min_size2 &&
		        scalar(@ordered_observation_ratios2_tmp));
		@$remainder2_2 = @ordered_observation_ratios2_tmp;
		push(@$tmp_group2_2,shift(@no_observations2))
		  while(scalar(@$tmp_group2_2) < $min_size2 &&
			scalar(@no_observations2));

		$ave1 = mean([map {$expanded_sample_info->{$_}->{$state} /
				     ($expanded_sample_info->{$_}->{DP} ?
				      $expanded_sample_info->{$_}->{DP} :
				      1)} @$tmp_group1_2]);
		$ave2 = mean([map {$expanded_sample_info->{$_}->{$state} /
				     ($expanded_sample_info->{$_}->{DP} ?
				      $expanded_sample_info->{$_}->{DP} :
				      1)} @$tmp_group2_2]);
		my $gap2 = abs($ave1 - $ave2);

		#The version of the groups with the larger gap is better
		if($gap2 > $gap1)
		  {
		    $gap1           = $gap2;
		    @$tmp_group1_1  = @$tmp_group1_2;
		    @$tmp_group2_1  = @$tmp_group2_2;
		    @$remainder1_1  = @$remainder1_2;
		    @$remainder2_1  = @$remainder2_2;
		    $leftright = 0;
		  }
	      }

	    #Now that we have the best group for this state, let's compare
	    #with previous states
	    if($gap1 > $best_gap || !defined($best_state))
	      {
		$best_gap         = $gap1;
		$best_state       = $state;
		@$best_group1     = @$tmp_group1_1;
		@$best_group2     = @$tmp_group2_1;
		@$best_remainder1 = @$remainder1_1;
		@$best_remainder2 = @$remainder2_1;
		$best_leftright   = $leftright;
	      }
	  }

	@$min_group1      = @$best_group1;
	@$min_group2      = @$best_group2;
	@$real_remainder1 = @$best_remainder1;
	@$real_remainder2 = @$best_remainder2;
	$case_leftright   = $best_leftright;
      }

    if(scalar(@$min_group1) < $min_size1 || scalar(@$min_group1) == 0)
      {error("Min sample group 1 size: [",scalar(@$min_group1),
	     "] less than minimum: [",(defined($min_size1) ?
				       $min_size1 : 'undef'),"].")}
    if(scalar(@$min_group2) < $min_size2 || scalar(@$min_group2) == 0)
      {error("Min sample group 2 size: [",scalar(@$min_group2),
	     "] less than minimum: [",(defined($min_size2) ?
				       $min_size2 : 'undef'),"].")}

    return($min_group1,$min_group2,
	   $real_remainder1,$real_remainder2,
	   $case_leftright);
  }


#This sorts via observation ratios.  Assumes 0 depth is 0 observations, so
#filter supplied samples for a depth greater than 0.
sub compareSampleObservationRatios
  {
    my $left_sample   = $_[0];
    my $right_sample  = $_[1];
    my $variant_state = $_[2];
    my $sample_info   = $_[3];

    return(($sample_info->{$left_sample}->{$variant_state} /
	    ($sample_info->{$left_sample}->{DP} ?
	     $sample_info->{$left_sample}->{DP} : 1)) <=>
	   ($sample_info->{$right_sample}->{$variant_state} /
	    ($sample_info->{$right_sample}->{DP} ?
	     $sample_info->{$right_sample}->{DP} : 1)));
  }


#Returns a number that has been rounded to a number of significant digits.  Only
#rounds decimal values between 0 and 1 and no scientific notation.  Otherwise,
#it returns the number as-is.
sub sigdec
  {
    my $dec = $_[0];
    my $digs = defined($_[1]) ? $_[1] : 4;

    if($dec !~ /^0*\.\d+$/)
      {return($dec)}

    if($digs == 0)
      {return($dec < 0.5 ? 0 : 1)}
    elsif($digs < 0)
      {
	error("Invalid number of significant digits: [$digs].");
	return($dec);
      }

    $digs--;

    if($dec =~ /(0*\.(0*[1-9]\d{$digs}))(\d)/)
      {
	my $trunc = $1;
	my $dp    = length($2);
	my $next  = $3;
	if($next >= 5)
	  {
	    my $inc = '0.' . ('0' x ($dp - 1)) . '1';
	    return($trunc + $inc);
	  }
	else
	  {return($trunc)}
      }

    return($dec);
  }

#This allows us to equate decimal values when sorting.  Just supply 2 decimal
#values.  If the allotment of digits is the same, 0 is returned, otherwise the
#result of <=>
sub compareDec
  {
    my $left  = $_[0];
    my $right = $_[1];

    if($left eq $right)
      {return(0)}

    return($left <=> $right);
  }

sub intRound
  {
    my $num = $_[0];
    if($num =~ /^\d*\.(\d)\d*$/)
      {
	my $d = $1;
	$num = int($num) + ($d < 5 ? 0 : 1);
      }
    return($num);
  }

sub sampleGroupPairPasses
  {
    my $group1      = $_[0];
    my $group2      = $_[1];
    my $sample_info = $_[2];

    my $pass = 0;

    if($genotype)
      {
	my $g1_gts = {map {$sample_info->{$_}->{GT} => 1}
		      grep {$sample_info->{$_}->{GT} !~ /\./} @$group1};
	my $g2_gts = {map {$sample_info->{$_}->{GT} => 1}
		      grep {$sample_info->{$_}->{GT} !~ /\./} @$group2};
	my $common_gts = [grep {exists($g2_gts->{$_})} keys(%$g1_gts)];
	$pass = (scalar(grep {$sample_info->{$_}->{GT} !~ /\./} @$group1) ==
		 scalar(@$group1) &&
		 scalar(grep {$sample_info->{$_}->{GT} !~ /\./} @$group2) ==
		 scalar(@$group2) &&
		 scalar(@$common_gts) == 0) ? 1 : 0;
      }
    else
      {
	my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);
	my @variant_states = ('RO',@$ao_keys);
	foreach my $state (@variant_states)
	  {
	    my $ave1 = mean([map {$expanded_sample_info->{$_}->{$state} /
				    ($expanded_sample_info->{$_}->{DP} ?
				     $expanded_sample_info->{$_}->{DP} : 1)}
			     @$group1]);
	    my $ave2 = mean([map {$expanded_sample_info->{$_}->{$state} /
				    ($expanded_sample_info->{$_}->{DP} ?
				     $expanded_sample_info->{$_}->{DP} : 1)}
			     @$group2]);
	    my $any_real1 =
	      scalar(grep {$sample_info->{$_}->{GT} !~ /\./} @$group1);
	    my $any_real2 =
	      scalar(grep {$sample_info->{$_}->{GT} !~ /\./} @$group2);

	    if($any_real1 && $any_real2 &&
	       abs($ave1 - $ave2) >= $separation_gap)
	      {
		$pass = 1;
		last;
	      }
	  }
      }

    debug("Group 1: [@$group1] values: [",join(',',map {$sample_info->{$_}->{GT}} @$group1),"]\nGroup 2: [@$group2] values: [",join(',',map {$sample_info->{$_}->{GT}} @$group2),"]\nPass: $pass");

    return($pass);
  }


sub getBestScoringData
  {
    my $group1      = $_[0];
    my $group2      = $_[1];
    my $sample_info = $_[2];

    my $score   = 0;
    my $state   = '';
    my $data1   = [];
    my $data2   = [];

    my $g1sum = 0;
    foreach my $sample (@$group1)
      {$g1sum += $sample_info->{$sample}->{DP}}
    my $g2sum = 0;
    foreach my $sample (@$group2)
      {$g2sum += $sample_info->{$sample}->{DP}}

    my $dpsum = 0;
    foreach my $sample (@$group1,@$group2)
      {$dpsum += $sample_info->{$sample}->{DP}}
    my $avedp = $dpsum / (scalar(@$group1) + scalar(@$group2));

    if($genotype)
      {
	my $g1_gts = {map {$sample_info->{$_}->{GT} => 1}
		      grep {$sample_info->{$_}->{GT} !~ /\./} @$group1};
	my $g2_gts = {map {$sample_info->{$_}->{GT} => 1}
		      grep {$sample_info->{$_}->{GT} !~ /\./} @$group2};
	my $common_gts = [grep {exists($g2_gts->{$_})} keys(%$g1_gts)];

	if(scalar(@$common_gts))
	  {$score = 0}
	else
	  {$score = (scalar(grep {$sample_info->{$_}->{GT} !~ /\./} @$group1) /
		     scalar(@$group1)) *
		       (scalar(grep {$sample_info->{$_}->{GT} !~ /\./}
			       @$group2) / scalar(@$group2))}

	#The state is the combo of unique genotypes present in each group
	$state  = join('+',keys(%$g1_gts)) . ';' . join('+',keys(%$g2_gts));

	#The data is the raw genotype calls
	@$data1 = map {$sample_info->{$_}->{GT}} @$group1;
	@$data2 = map {$sample_info->{$_}->{GT}} @$group2;
      }
    else
      {
	my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);
	my @variant_states = ('RO',@$ao_keys);
	my $cur_score = 0;
	foreach my $cur_state (@variant_states)
	  {
	    my $ave1 = mean([map {$expanded_sample_info->{$_}->{$cur_state} /
				    ($expanded_sample_info->{$_}->{DP} ?
				     $expanded_sample_info->{$_}->{DP} : 1)}
			     @$group1]);
	    my $ave2 = mean([map {$expanded_sample_info->{$_}->{$cur_state} /
				    ($expanded_sample_info->{$_}->{DP} ?
				     $expanded_sample_info->{$_}->{DP} : 1)}
			     @$group2]);
	    $cur_score = abs($ave1 - $ave2);

	    #Base the best score on the variant state with the best separation
	    #gap.  If there are multiple variant states that produce the same
	    #best score, go with the one that's not the same as the reference.
	    if($cur_score > $score ||
	       (#The decimal values are the same and the cur state is not 'RO'
		($cur_score == $score || $cur_score eq $score) &&
		$cur_state ne 'RO'))
	      {
		$score = $cur_score;
		my $tmp_state = $cur_state;
		$tmp_state =~ s/AO(\d)/$1/;
		$tmp_state = 0 if($tmp_state eq 'RO');
		$tmp_state = 1 if($tmp_state eq 'AO');
		$state = $tmp_state;
		#The data is the list of observation ratios
		@$data1 = (map {$expanded_sample_info->{$_}->{DP} ?
				  "$expanded_sample_info->{$_}->{$cur_state}" .
				    "/$expanded_sample_info->{$_}->{DP}" : '.'}
			   @$group1);
		@$data2 = (map {$expanded_sample_info->{$_}->{DP} ?
				  "$expanded_sample_info->{$_}->{$cur_state}" .
				    "/$expanded_sample_info->{$_}->{DP}" : '.'}
			   @$group2);
	      }
	  }
      }

    if($g1sum == 0 || $g2sum == 0)
      {return({RANK    => 0,
	       AVEDP   => 0,
	       STATE   => '.',
	       SCORES1 => $data1,
	       SCORES2 => $data2})}

    return({RANK    => $score,
	    AVEDP   => $avedp,
	    STATE   => $state,
	    SCORES1 => $data1,
	    SCORES2 => $data2});
  }


#Call this to create sample groups dynamically (when no sample groups have been
#defined).  It starts by creating the best groups it can using the minimum group
#sizes.  When in genotype mode, that means the groups gave no common genotype
#(or as few common genotypes as possible.  When in nogenotype mode, it selects
#the variant state that results in the largest observation ratio gap when
#drawing from opposite ends of a sample list ordered by observation ratios of
#the selected variant state.  In each case, the best minimum groups are grown
#until just before they cross the threshold making the groups a non-hit, meaning
#in genotype mode, it grows the sample groups up until they would end up with a
#common genotype, or in nogenotype mode, it grows them until just before the
#average observation ratios of the groups dips below the separation gap
#threshold.
#Known issue: When selecting between 2 minimum group sizes that have the same
#"score" (i.e. the same gap size or assortment of unique genotypes), the
#selection is made arbitrarily.  It doesn't look ahead to see which selection
#would result in the largest group sizes at the grow step.
sub createSampleGroups
  {
    my $sample_info     = $_[0];
    my $min_group_sizes = $_[1];

    my $groups = []; #A 2D array

    if(scalar(@$min_group_sizes) % 2)
      {
	error("Odd number of minimum grouyp sizes encountered: [",
	      scalar(@$min_group_sizes),"].  Must be even.  Unable to ",
	      "proceed.");
	quit(9);
      }
    elsif(scalar(@$min_group_sizes) == 0)
      {
	error("Empty minimum group sizes array.  Unable to proceed.");
	quit(10);
      }

    if(scalar(keys(%$sample_info)) == 0)
      {
	error("Empty sample info hash.  Unable to proceed.");
	quit(11);
      }

    for(my $mi = 0;$mi < scalar(@$min_group_sizes);$mi += 2)
      {
	#Make sure the first size is the lerger size
	my($min_size1,$min_size2) = sort {$b <=> $a}
	  ($min_group_sizes->[$mi],$min_group_sizes->[$mi + 1]);
	my $group1 = [];
	my $group2 = [];

	if(($min_size1 + $min_size2) > scalar(keys(%$sample_info)))
	  {
	    error("Invalid minimum sample group sizes.  Pair [",($mi + 1),
		  "] of minimum group sizes [$min_size1,$min_size2] must not ",
		  "sum [",($min_size1 + $min_size2),"] to more than the ",
		  "number of samples: [",scalar(keys(%$sample_info)),
		  "].  Unable to proceed.");
	    quit(12);
	  }

	##
	## The following code differs from that in createMinSampleGroupPair
	## because this version creates the pair of groups using a single sample
	## list and an empty list of sample groups whereas the code in
	## createMinSampleGroupPair uses 2 populated full sample groups and
	## creates a minimum group out of each
	##

	#If we're in genotype mode
	if($genotype)
	  {
	    #Establish the ordering of the samples by genotype abundance
	    my $genotype_counts = {};
	    foreach my $sample (keys(%$sample_info))
	      {$genotype_counts->{$sample_info->{$sample}->{GT}}++}
	    my @ordered_gts_real =
	      sort {$genotype_counts->{$sample_info->{$b}->{GT}} <=>
		      $genotype_counts->{$sample_info->{$a}->{GT}}}
		grep {$sample_info->{$_}->{GT} !~ /\./} keys(%$sample_info);
	    my @nocalls = grep {/\./} keys(%$sample_info);
	    my @samples_remaining = (@ordered_gts_real,@nocalls);
	    my $call = '';
	    while(scalar(@samples_remaining) &&
		  scalar(@$group1) < $min_size1 &&
		  scalar(@$group2) < $min_size2)
	      {
		#Start by populating the larger sample group using the more
		#abundant genotype call
		if(scalar(@$group1) < $min_size1)
		  {
		    if(scalar(@ordered_gts_real))
		      {$call = $sample_info->{shift(@ordered_gts_real)}->{GT}}
		    elsif(scalar(@nocalls))
		      {$call = $sample_info->{shift(@nocalls)}->{GT}}
		    else
		      {
			$call = $sample_info->{$samples_remaining[0]}->{GT};
			warning("Ran out of calls in dynamic sample group ",
				"creation.");
			last;
		      }

		    #Add a new call to group 1 (the larger group)
		    if($call eq '')
		      {
			push(@$group1,shift(@samples_remaining))
			  while(scalar(@$group1) < $min_size1 &&
				scalar(@samples_remaining));
		      }
		    else
		      {
			push(@$group1,
			     grep {$sample_info->{$_}->{GT} eq $call}
			     @samples_remaining);
		      }

		    #Trim back the group if it ended up too large
		    if(scalar(@$group1) > $min_size1)
		      {pop(@$group1) while(scalar(@$group1) > $min_size1)}

		    #Remove samples from those remaining
		    @samples_remaining =
		      grep {my $s=$_;scalar(grep {$_ eq $s} @$group1) == 0}
			@samples_remaining;
		  }

		#Now try to populate the smaller sample group using the less
		#abundant genotype call (if one exists)
		if(scalar(@$group2) < $min_size2)
		  {
		    if(scalar(@ordered_gts_real))
		      {$call = $sample_info->{pop(@ordered_gts_real)}->{GT}}
		    elsif(scalar(@nocalls))
		      {$call = $sample_info->{shift(@nocalls)}->{GT}}
		    else
		      {
			my @tmp = grep {$sample_info->{$_}->{GT} !~ /\./}
			  @samples_remaining;
			if(scalar(@tmp))
			  {$call = $sample_info->{$tmp[-1]}->{GT}}
			else
			  {$call = ''}
			warning("Ran out of calls in dynamic sample group ",
				"creation.");
			last;
		      }

		    #Add a new call to group 2 (the smaller group)
		    if($call eq '')
		      {
			push(@$group2,shift(@samples_remaining))
			  while(scalar(@$group2) < $min_size2 &&
				scalar(@samples_remaining));
		      }
		    else
		      {
			push(@$group2,
			     grep {$sample_info->{$_}->{GT} eq $call}
			     @samples_remaining);
		      }

		    #Trim back the group if it ended up too large
		    if(scalar(@$group2) > $min_size2)
		      {pop(@$group2) while(scalar(@$group2) > $min_size2)}

		    #Remove samples from those remaining
		    @samples_remaining =
		      grep {my $s=$_;scalar(grep {$_ eq $s} @$group2) == 0}
			@samples_remaining;
		  }
	      }

	    #Grow the groups to the max size without adding to inconsistencies
	    my $g1_gts = {map {$sample_info->{$_}->{GT} => 1}
			  grep {$sample_info->{$_}->{GT} !~ /\./} @$group1};
	    my $g2_gts = {map {$sample_info->{$_}->{GT} => 1}
			  grep {$sample_info->{$_}->{GT} !~ /\./} @$group2};
	    foreach my $sample (@samples_remaining)
	      {
		my $gt = $sample_info->{$sample}->{GT};
		if(exists($g1_gts->{$gt}) && !exists($g2_gts->{$gt}))
		  {push(@$group1,$sample)}
		elsif(!exists($g1_gts->{$gt}) && exists($g2_gts->{$gt}))
		  {push(@$group2,$sample)}
	      }

	    #Make the groups match the original order of the minimum sizes
	    push(@$groups,($min_group_sizes->[$mi] == $min_size1 ?
			   ($group1,$group2) : ($group2,$group1)));
	  }
	else #nogenotype - use observation ratios - easier than above
	  {
	    my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);
	    my @variant_states = ('RO',@$ao_keys);
	    my $remainder    = [];
	    my $best_group1  = [];
	    my $best_group2  = [];
	    my($best_state);
	    my $best_gap     = 0;
	    foreach my $state (@variant_states)
	      {
		my $tmp_group1_1 = [];
		my $tmp_group2_1 = [];
		my $tmp_group1_2 = [];
		my $tmp_group2_2 = [];

		my @ordered_observation_ratios =
		  sort {compareSampleObservationRatios($a,$b,$state,
						       $expanded_sample_info)}
		    grep {$expanded_sample_info->{$_}->{DP}}
		      keys(%$sample_info);
		my @no_observations = grep {!$expanded_sample_info->{$_}->{DP}}
		  keys(%$sample_info);

		#Try creating group 1 from the left and 2 from the right
		my @ordered_observation_ratios_tmp =
		  @ordered_observation_ratios;
		while((scalar(@$tmp_group1_1) < $min_size1 ||
		       scalar(@$tmp_group2_1) < $min_size2) &&
		      scalar(@ordered_observation_ratios_tmp))
		  {
		    push(@$tmp_group1_1,shift(@ordered_observation_ratios_tmp))
		      if(scalar(@$tmp_group1_1) < $min_size1);
		    push(@$tmp_group2_1,pop(@ordered_observation_ratios_tmp))
		      if(scalar(@$tmp_group2_1) < $min_size2 &&
			 scalar(@ordered_observation_ratios_tmp));
		  }
		while((scalar(@$tmp_group1_1) < $min_size1 ||
		       scalar(@$tmp_group2_1) < $min_size2) &&
		      scalar(@no_observations))
		  {
		    push(@$tmp_group1_1,shift(@no_observations))
		      if(scalar(@$tmp_group1_1) < $min_size1);
		    push(@$tmp_group2_1,shift(@no_observations))
		      if(scalar(@$tmp_group2_1) < $min_size2 &&
			 scalar(@no_observations));
		  }
		my $remainder_tmp    = [@ordered_observation_ratios_tmp];
		my $no_obs_remainder = [@no_observations];

		my $ave1 = mean([map {$expanded_sample_info->{$_}->{$state} /
					($expanded_sample_info->{$_}->{DP} ?
					 $expanded_sample_info->{$_}->{DP} : 1)}
				 @$tmp_group1_1]);
		my $ave2 = mean([map {$expanded_sample_info->{$_}->{$state} /
					($expanded_sample_info->{$_}->{DP} ?
				         $expanded_sample_info->{$_}->{DP} : 1)}
				 @$tmp_group2_1]);
		my $gap1 = abs($ave1 - $ave2);

		#Now try the opposite (if the sizes are different)
		if($min_size1 != $min_size2)
		  {
		    #Try creating group 1 from the right and 2 from the left
		    @ordered_observation_ratios_tmp =
		      @ordered_observation_ratios;
		    @no_observations = grep {!$expanded_sample_info->{$_}->{DP}}
		      keys(%$sample_info);
		    while((scalar(@$tmp_group1_2) < $min_size1 ||
			   scalar(@$tmp_group2_2) < $min_size2) &&
			  scalar(@ordered_observation_ratios_tmp))
		      {
			push(@$tmp_group1_2,
			     pop(@ordered_observation_ratios_tmp))
			  if(scalar(@$tmp_group1_2) < $min_size1);
			push(@$tmp_group2_2,
			     shift(@ordered_observation_ratios_tmp))
			  if(scalar(@$tmp_group2_2) < $min_size2 &&
			     scalar(@ordered_observation_ratios_tmp));
		      }
		    while((scalar(@$tmp_group1_2) < $min_size1 ||
			   scalar(@$tmp_group2_2) < $min_size2) &&
			  scalar(@no_observations))
		      {
			push(@$tmp_group1_2,shift(@no_observations))
			  if(scalar(@$tmp_group1_2) < $min_size1);
			push(@$tmp_group2_2,shift(@no_observations))
			  if(scalar(@$tmp_group2_2) < $min_size2 &&
			     scalar(@no_observations));
		      }

		    $ave1 = mean([map {$expanded_sample_info->{$_}->{$state} /
					 ($expanded_sample_info->{$_}->{DP} ?
					  $expanded_sample_info->{$_}->{DP} :
					  1)} @$tmp_group1_1]);
		    $ave2 = mean([map {$expanded_sample_info->{$_}->{$state} /
					 ($expanded_sample_info->{$_}->{DP} ?
					  $expanded_sample_info->{$_}->{DP} :
					  1)} @$tmp_group2_1]);
		    my $gap2 = abs($ave1 - $ave2);

		    #The version of the groups with the larger gap is better
		    if($gap2 > $gap1)
		      {
			$gap1 = $gap2;
			@$tmp_group1_1 = @$tmp_group1_2;
			@$tmp_group2_1 = @$tmp_group2_2;
			@$remainder_tmp =
			  reverse(@ordered_observation_ratios_tmp);
			@$no_obs_remainder = @no_observations;
		      }
		  }

		#Now that we have the best group for this state, let's compare
		#with previous states
		if($gap1 > $best_gap || !defined($best_state))
		  {
		    $best_gap     = $gap1;
		    $best_state   = $state;
		    @$best_group1 = @$tmp_group1_1;
		    @$best_group2 = @$tmp_group2_1;
		    @$remainder   = @$remainder_tmp;
		  }
	      }

	    #Grow the groups to max size without exceeding the separation gap
	    #We're going to ignore samples with no observations in the grow step
	    while(scalar(@$remainder))
	      {
		my $first_sample = $remainder->[0];
		my $last_sample  = $remainder->[-1];

		#Determine the existing averages
		my $group1_ave =
		  mean([map {$expanded_sample_info->{$_}->{$best_state} /
			       ($expanded_sample_info->{$_}->{DP} ?
				$expanded_sample_info->{$_}->{DP} :
				1)} @$best_group1]);
		my $group2_ave =
		  mean([map {$expanded_sample_info->{$_} ->{$best_state} /
			       ($expanded_sample_info->{$_}->{DP} ?
				$expanded_sample_info->{$_}->{DP} :
				1)} @$best_group2]);

		last if(abs($group1_ave - $group2_ave) < $separation_gap);

		my $new_ave1 =
		  mean([map {$expanded_sample_info->{$_}->{$best_state} /
			       ($expanded_sample_info->{$_}->{DP} ?
				$expanded_sample_info->{$_}->{DP} :
				1)} (@$best_group1,$first_sample)]);

		#Whether or not @$remainder has more than 1 member, the result
		#will be the same
		my $new_ave2 =
		  mean([map {$expanded_sample_info->{$_}->{$best_state} /
			       ($expanded_sample_info->{$_}->{DP} ?
				$expanded_sample_info->{$_}->{DP} :
				1)} (@$best_group2,$last_sample)]);

		#Determine which will result in a smaller gap change
		my $better = 1;
		if(abs($group1_ave - $new_ave1) > abs($group2_ave - $new_ave2))
		  {$better = 2}

		#If the better gap change also results in a gap that's larger
		#than the separation gap threshold, add it to the best group
		if($better == 1 &&
		   abs($new_ave1 - $group2_ave) >= $separation_gap)
		  {
		    push(@$best_group1,$first_sample);
		    shift(@$remainder);
		  }
		elsif($better == 2 &&
		      abs($new_ave2 - $group1_ave) >= $separation_gap)
		  {
		    push(@$best_group2,$last_sample);
		    pop(@$remainder);
		  }
		else
		  {last}
	      }

	    #Make the groups match the original order of the minimum sizes
	    push(@$groups,($min_group_sizes->[$mi] == $min_size1 ?
			   ($best_group1,$best_group2) :
			   ($best_group2,$best_group1)));
	  }
      }

    debug("Returning groups of sizes: [",join(',',map {scalar(@$_)} @$groups),
	  "].",{LEVEL => 2});

    return(wantarray ? @$groups : $groups);
  }

sub mean
  {
    my $array = $_[0];
    return(0) unless(scalar(@$array));
    my $sum = 0;
    foreach my $val (@$array)
      {$sum += $val}
    return($sum / scalar(@$array));
  }

sub expandSampleInfo
  {
    my $sample_info = $_[0];
    my $expanded_sample_info = {};
    my $ao_keys = [];

    foreach my $sample (keys(%$sample_info))
      {
	foreach my $key (keys(%{$sample_info->{$sample}}))
	  {
	    my $val = $sample_info->{$sample}->{$key};
	    my @alts = split(/,/,$val,-1);
	    if(scalar(@alts) == 1)
	      {
		$expanded_sample_info->{$sample}->{$key} = $val;
		if($key eq 'AO' && scalar(@$ao_keys) == 0)
		  {push(@$ao_keys,'AO')}
	      }
	    else
	      {
		if($key eq 'RO' || $key eq 'DP')
		  {
		    error("Multiple values found in $key key [$val].",
			  {DETAIL => 'This script assumes that the FORMAT ' .
			   'keys "DP" and "RO" each have a single (comma-' .
			   'delimited) value, but found more than 1.'});
		  }

		if($key eq 'AO' && scalar(@$ao_keys) == 0)
		  {push(@$ao_keys,map {"AO$_"} (1..scalar(@alts)))}

		for(my $i = 0;$i <= $#alts;$i++)
		  {$expanded_sample_info->{$sample}->{$key .($i+1)} = $alts[$i]}
	      }
	  }
      }

    return($expanded_sample_info,$ao_keys);
  }

sub max
  {
    my @vals = @_;
    return(undef) unless(scalar(@vals));
    my $max  = $vals[0];
    foreach my $val (@vals)
      {if(!defined($max) || $val > $max)
	 {$max = $val}}
    return($max);
  }

sub validateSampleGroupNames
  {
    my $sample_names  = $_[0];
    my $sample_groups = $_[1];

    my $status = 1; #1 = success/validated
    my $unique = {};
    foreach my $sample (@$sample_names)
      {$unique->{$sample}++}
    foreach my $dupe (grep {$unique->{$_} > 1} keys(%$unique))
      {
	$status = 0;
	error("Sample name [$dupe] occurs [$unique->{$dupe}] in the vcf ",
	      "file.",
	      {DETAIL => 'Sample names must be unique when -s is supplied'});
      }

    my $missing = {};
    foreach my $pair_index ((0..$#{$sample_groups}))
      {
	foreach my $sample_name (grep {!exists($unique->{$_})}
				 @{$sample_groups->[$pair_index]})
	  {
	    $status = 0;
	    error("Sample name submitted with -s [$sample_name] was not ",
		  "found in the vcf file.",
		  {DETAIL => join('',('Sample names submitted with -s must ',
				      'exactly match those present on the ',
				      'header line in the vcf file (the line ',
				      'starting with "#CHROM").  The VCF ',
				      'file contains: [',
				      join(',',@$sample_names),'].'))});
	  }
      }

    return($status);
  }
